/*
 * sockClient.cpp
 *
 *  Created on: Nov 17, 2018
 *      Author: programmer
 */

#include <iostream>
#include <sys/types.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <string.h>
#include <string>
#include "sockClient.h"

using namespace std;

/*todo:
 * create object X
 * Create socket X
 * create hint for server we re connectin
 * connect to socket
 * read
 * write
 * close/destroy
 */

//create object
sockClient::sockClient()
{
	sock = -1; //default -1 to indicate it hasnt been started yet
	port = 0; //variable to store port number
	address = ""; //variable to store address

	//server;
}

sockClient::sockClient(string addr, int prt)
{
	sock = -1; //default -1 to indicate it hasnt been started yet
	port = prt; //variable to store port number
	address = addr; //variable to store address
	//server;
}

//create socket
int sockClient::createSock(sockClient* sc)
{
	if (sc->sock == -1) //Socket not yet created or failed to create on last try.
	{
		sc->sock = socket(AF_INET, SOCK_STREAM, 0); //create socket(ipv4, tcp, protocol auto)
	}
	if (sc->sock == -1) //Failed to create socket
	{
		cerr << "Failed to create socket" << endl;
		return 1;
	}
	return 0;
}

//create hint structure for the server we want to connect with./////////
void sockClient::setHint(sockClient* sc)
{
	sc->server.sin_family = AF_INET; //ipv4
	sc->server.sin_port = htons(sc->port); //string to network short (small endian?)
	inet_pton(AF_INET, sc->address.c_str(), &sc->server.sin_addr); //convert to sin addr
}


bool sockClient::connectToServer(sockaddr_in sa, sockClient* sc)
{
	//connect to hint

	int connection = connect(sc->sock, (sockaddr*)&sa, sizeof(sa));
	if (connection == -1)
	{
		cerr << " unable to connect" <<endl;
		return false;
	}
	return true;
}

bool sockClient::sendToServer(string data) //send
{
	//socket, data as c string, datasize +1 because the conversion to a c string adds an extra (\0) to the string
	int sendResult = send(this->sock, data.c_str(), data.size() + 1, 0);
	if (sendResult == -1) //unable to send
	{
		cerr << "Unable to send data to server." << endl;
		return false;
	}
	else
	{
		return true;
	}

}

string sockClient::receiveFromServer(sockClient* sc) //receive
{

}

void sockClient::closeSocket(sockClient* sc){
	if(sc->sock == -1){ //check if socket exists
		cerr << "Socket has already been closed" << endl;
	}
	else{ //close socket
		close(sc->sock);
	}
}

