/*
 * sockClient.cpp
 *
 *  Created on: Nov 17, 2018
 *      Author: programmer
 */

#include <iostream>	//cout
#include <stdio.h>	//printf
#include <string.h> //strlen
#include <string>	//string
#include <sys/socket.h>	//socket
#include <arpa/inet.h>	//inet_addr
#include <netdb.h>	//hostent
#include "sockClient.h"

using namespace std;

/*todo:
 * create object X
 * Create socket X
 * create hint for server we re connectin
 * connect to socket
 * read
 * write
 * close/destroy
 */

//create object
sockClient::sockClient()
{
	sock = -1; //default -1 to indicate it hasnt been started yet
	port = 0; //variable to store port number
	address = ""; //variable to store address
	//server;
}

sockClient::sockClient(string addr, int prt)
{
	sock = -1; //default -1 to indicate it hasnt been started yet
	port = prt; //variable to store port number
	address = addr; //variable to store address
	//server;
}

//create socket
int sockClient::createSock(sockClient sc)
{
	if (sc.sock == -1) //Socket not yet created or failed to create on last try.
	{
		sc.sock = socket(AF_INET, SOCK_STREAM, 0); //create socket(ipv4, tcp, protocol auto)
	}
	if (sc.sock == -1) //Failed to create socket
	{
		cerr << "Failed to create socket" << endl;
		return 1;
	}
	return 0;
}

//create hint structure for the server we want to connect with./////////
void sockClient::setHint(sockClient sc){
	sc.server.sin_family = AF_INET; //ipv4
	sc.server.sin_port = htons(sc.port); //string to network short (small endian?)
	inet_pton(AF_INET, sc.address.c_str(), &sc.server.sin_addr); //convert to sin addr
}


//
bool connectToServer(sockClient sc)
{
	//connect to hint
}

bool sendToServer(string data) //send
{

}

string receiveFromServer(sockClient sc) //receive
{

}

int closeSocket(sockClient sc){

	int close(sc.sock);
}




/*
bool sockClient::conn(string address , int port)
{
	//create socket if it is not already created
	if(sock == -1)
	{
		//Create socket
		sock = socket(AF_INET , SOCK_STREAM , 0);
		if (sock == -1)
		{
			const char e[] = "Could not create socket";
			cerr << (e);
		}

		cout<<"Socket created\n";
	}
	else	{	}

	//setup address structure
	if(inet_addr(address.c_str()) == -1)
	{
		struct hostent *he;
		struct in_addr **addr_list;

		//resolve the hostname, its not an ip address
		if ( (he = gethostbyname( address.c_str() ) ) == NULL)
		{
			//gethostbyname failed
			herror("gethostbyname");
			cout<<"Failed to resolve hostname\n";

			return false;
		}

		//Cast the h_addr_list to in_addr , since h_addr_list also has the ip address in long format only
		addr_list = (struct in_addr **) he->>h_addr_list;

		for(int i = 0; addr_list[i] != NULL; i++)
		{
			//strcpy(ip , inet_ntoa(*addr_list[i]) );
			server.sin_addr = *addr_list[i];

			cout<<address<<" resolved to "<<inet_ntoa(*addr_list[i])<<endl;

			break;
		}
	}

	//plain ip address
	else
	{
		server.sin_addr.s_addr = inet_addr( address.c_str() );
	}

	server.sin_family = AF_INET;
	server.sin_port = htons( port );

	//Connect to remote server
	if (connect(sock , (struct sockaddr *)&amp;server , sizeof(server)) < 0)
	{
		perror("connect failed. Error");
		return 1;
	}

	cout<<"Connected\n";
	return true;
}

/**
	Send data to the connected host
bool sockClient::send_data(string data)
{
	//Send some data
	if( send(sock , data.c_str() , strlen( data.c_str() ) , 0) < 0)
	{
		perror("Send failed : ");
		return false;
	}
	cout<<"Data send\n";

	return true;
}

/**
	Receive data from the connected host

string sockClient::receive(int size=512)
{
	char buffer[size];
	string reply;

	//Receive a reply from the server
	if( recv(sock , buffer , sizeof(buffer) , 0) < 0)
	{
		puts("recv failed");
	}

	reply = buffer;
	return reply;
}

int main(int argc , char *argv[])
{
	sockClient c;
	string host;

	cout<<"Enter hostname : ";
	cin>>host;

	//connect to host
	c.conn(host , 80);

	//send some data
	c.send_data("GET / HTTP/1.1\r\n\r\n");

	//receive and echo reply
	cout<<"----------------------------\n\n";
	cout<<c.receive(1024);
	cout<<"\n\n----------------------------\n\n";

	//done
	return 0;
}
*/
